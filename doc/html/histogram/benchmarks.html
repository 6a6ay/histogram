<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Benchmarks</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="prev" href="user_guide.html" title="User guide">
<link rel="next" href="rationale.html" title="Rationale">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="user_guide.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="rationale.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="histogram.benchmarks"></a><a class="link" href="benchmarks.html" title="Benchmarks">Benchmarks</a>
</h2></div></div></div>
<p>
      The library is designed to be fast. While it is unlikely that the time spend
      in the histogram is limiting an application, we cannot predict how the library
      is used.
    </p>
<p>
      The following plot shows results of a benchmark on a 9 GHz Macbook Pro. Random
      numbers from a uniform and a normal distribution are filled into histograms
      with 1, 3, and 6 axes. 100 bins are used in the first case, 100x100x100=10^6
      in the second, and 10x10x10x10x10x10=10^6 in the third. Each test is repeated
      50 times and the minimum time is taken.
    </p>
<p>
      <span class="inlinemediaobject"><img src="../../benchmark.png" width="450"></span>
    </p>
<div class="variablelist">
<p class="title"><b>Plot legend:</b></p>
<dl class="variablelist">
<dt><span class="term">root</span></dt>
<dd><p>
            <a href="https://root.cern.ch" target="_top">ROOT classes</a> (<code class="computeroutput"><span class="identifier">TH1I</span></code> for 1D, <code class="computeroutput"><span class="identifier">TH3I</span></code>
            for 3D and <code class="computeroutput"><span class="identifier">THnI</span></code> for 6D)
          </p></dd>
<dt><span class="term">py:numpy</span></dt>
<dd><p>
            numpy functions (<code class="computeroutput"><span class="identifier">numpy</span><span class="special">.</span><span class="identifier">histogram1d</span></code>
            for 1D, <code class="computeroutput"><span class="identifier">numpy</span><span class="special">.</span><span class="identifier">histogramdd</span></code> for 3D and 6D)
          </p></dd>
<dt><span class="term">py:hd_sd</span></dt>
<dd><p>
            <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">histogram&lt;Dynamic, Axes,
            adaptive_storage&lt;&gt;&gt;</a></code> called from Python
          </p></dd>
<dt><span class="term">hs_ss</span></dt>
<dd><p>
            <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">Axes, container_storage&lt;std::vector&lt;int&gt;&gt;&gt;</a></code>
          </p></dd>
<dt><span class="term">hs_sd</span></dt>
<dd><p>
            <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">Axes, adaptive_storage&lt;&gt;</a></code>
          </p></dd>
<dt><span class="term">hd_ss</span></dt>
<dd><p>
            <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">Axes, container_storage&lt;std::vector&lt;int&gt;&gt;</a></code>
          </p></dd>
<dt><span class="term">hd_sd</span></dt>
<dd><p>
            <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">Axes, adaptive_storage&lt;&gt;</a></code>
          </p></dd>
</dl>
</div>
<p>
      <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">Axes, Storage&gt;</a></code>
      is always faster than <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">Axes,
      Storage&gt;</a></code> and safer to use, as more checks are done at compile
      time. It is recommended when working in C++ only. <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">boost::histogram::adaptive_storage</a></code>
      is faster than <code class="computeroutput"><a class="link" href="../boost/histogram/container_storage.html" title="Class template container_storage">boost::histogram::container_storage</a></code>
      for histograms with many bins, because it uses the cache more effectively due
      to its smaller memory consumption per bin. If the number of bins is small,
      the latter is faster since it does not reallocate memory to increase the element
      size.
    </p>
<p>
      The histograms in this library are mostly faster than the competition, in some
      cases by a factor of 2. Simultaneously they are more flexible, since binning
      strategies can be customised. The Python-wrapped histogram is slower than numpy's
      own specialized function for 1D, but beats numpy's general multi-dimensional
      function by a factor 2 to 3.
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Hans Dembinski<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="user_guide.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="rationale.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
