<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Rationale</title>
<link rel="stylesheet" href="../../../../../doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Histogram">
<link rel="prev" href="benchmarks.html" title="Benchmarks">
<link rel="next" href="concepts.html" title="Concepts">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr>
<td valign="top"><img alt="Boost C++ Libraries" width="277" height="86" src="../../../../../boost.png"></td>
<td align="center"><a href="../../../../../index.html">Home</a></td>
<td align="center"><a href="../../../../../libs/libraries.htm">Libraries</a></td>
<td align="center"><a href="http://www.boost.org/users/people.html">People</a></td>
<td align="center"><a href="http://www.boost.org/users/faq.html">FAQ</a></td>
<td align="center"><a href="../../../../../more/index.htm">More</a></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="concepts.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="histogram.rationale"></a><a class="link" href="rationale.html" title="Rationale">Rationale</a>
</h2></div></div></div>
<div class="toc"><dl class="toc">
<dt><span class="section"><a href="rationale.html#histogram.rationale.structure">Structure</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.histogram_types">Histograms types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.axis_types">Axis types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.storage_types">Storage types</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.uoflow">Overflow and underflow bins</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.weights">Variance estimates</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.weigths">Support of weights</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.python_support">Python support</a></span></dt>
<dt><span class="section"><a href="rationale.html#histogram.rationale.serialization">Serialization</a></span></dt>
</dl></div>
<p>
      This library was designed based on a decade of experience collected in working
      with big data, more precisely in the field of particle physics and astroparticle
      physics.
    </p>
<p>
      The design is guided by these principles.
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          "Do one thing and do it well", Doug McIlroy
        </li>
<li class="listitem">
          The <a href="https://www.python.org/dev/peps/pep-0020" target="_top">Zen of Python</a>
          (also applies to other languages).
        </li>
</ul></div>
<p>
      The library is build on advice from C++ experts, like Bjarne Stroustrup, Scott
      Meyers, Herb Sutter, and Andrei Alexandrescu, and Chandler Carruth.
    </p>
<p>
      The library was written with two major goals in mind:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Provide the same interface for one-dimensional and multi-dimensional histograms.
          This makes the interface easier to learn. A consistent multi-dimensional
          interface makes it also easier to change the code, if a histogram is revised
          to have more axes. The one-dimensional case can be conveniently treated
          as a special case of the multi-dimensional one. Thanks to template metaprogramming,
          the compiler can emit optimised code for the one-dimensional case.
        </li>
<li class="listitem">
          Completely hide the details of how the counting is done. Other implementations,
          notably those in the <a href="https://root.cern.ch" target="_top">ROOT framework</a>
          expose this, which forces the user to make a choice which is potentially
          dangerous. At best, the choice is merely inefficient, but it can lead to
          information loss in form of overflowing or capped counters.
        </li>
</ul></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.structure"></a><a class="link" href="rationale.html#histogram.rationale.structure" title="Structure">Structure</a>
</h3></div></div></div>
<p>
        The library consists of three orthogonal components:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.histogram_types" title="Histograms types">histogram types</a>:
            Host class which defines the user interface and responsible for holding
            axis objects. The two implementions differ in the way axis objects are
            stored.
          </li>
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">axis types</a>: Defines
            how value ranges are mapped to bins. Several axis types are provided
            which implement different specializations.
          </li>
<li class="listitem">
            <a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">storage types</a>:
            Manages memory to hold bin counts. The requirements for a storage differ
            from those of an STL container. Two implementations are provided.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.histogram_types"></a><a class="link" href="rationale.html#histogram.rationale.histogram_types" title="Histograms types">Histograms types</a>
</h3></div></div></div>
<p>
        Histograms have a number of axes. An axis defines a mapping of ranges of
        input values to bin indices. The library supports several <a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">axis
        specializations</a>. The number of axes may be known at compile time or
        runtime, depending on how the library is used. The axis types may be known
        at compile time or runtime.
      </p>
<p>
        Users can chose between two histogram implementations. The implementation
        is selected with the first template argument, see <code class="computeroutput"><a class="link" href="../boost/histogram/histogram.html" title="Class template histogram">boost::histogram::histogram</a></code>.
        The static implementation is faster (see <a class="link" href="benchmarks.html" title="Benchmarks">benchmark</a>),
        because the compiler is able to inline more code and some bookkeeping and
        type casting at run-time is avoided. It is also able to catch many user errors
        at compile time rather than runtime.
      </p>
<p>
        The static approach is unpractical when the user wants to create histograms
        at runtime, for example, from Python or from a graphical user interface.
        The second implementation addresses this and allows one to set the number
        of axes and their types at runtime. The interface of the dynamic implementation
        is a superset of the static implementation. With the help of included utility
        functions it is possible to write code which works transparently with either
        implementation, thus allowing users to switch the implementation in their
        code at any point in time.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.axis_types"></a><a class="link" href="rationale.html#histogram.rationale.axis_types" title="Axis types">Axis types</a>
</h3></div></div></div>
<p>
        An axis defines which range of input values is mapped to which bin. The logic
        is encapsulated in an axis type. The library comes with five axis types,
        which implement different specializations.
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/regular_axis.html" title="Class template regular_axis">boost::histogram::regular_axis</a></code>
            sorts real numbers into bins with equal width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/variable_axis.html" title="Class template variable_axis">boost::histogram::variable_axis</a></code>
            sorts real numbers into bins with varying width.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/circular_axis.html" title="Class template circular_axis">boost::histogram::circular_axis</a></code>
            is a specialization of a regular axis for angles and other input that
            wraps around.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/integer_axis.html" title="Class integer_axis">boost::histogram::integer_axis</a></code>
            is a specialization of a regular axis for a continuous range of integers.
          </li>
<li class="listitem">
            <code class="computeroutput"><a class="link" href="../boost/histogram/category_axis.html" title="Class category_axis">boost::histogram::category_axis</a></code>
            is a specialization of an integer axis for categorical data, like "men"
            and "women".
          </li>
</ul></div>
<p>
        Library users can create their own axis classes and use them with the library,
        by providing a class compatible with the axis concept.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.storage_types"></a><a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">Storage types</a>
</h3></div></div></div>
<p>
        Dense (aka contiguous) storage in memory is needed for fast bin lookup, which
        is of the random-access variety and may be happening in a tight loop. All
        storage types therefore implement dense storage of bin counters. <code class="computeroutput"><a class="link" href="../boost/histogram/container_storage.html" title="Class template container_storage">boost::histogram::container_storage</a></code>
        implements a storage based on an STL-conforming container and that could
        be the end of story, but there are several issues with this approach. For
        one, it is not convenient, because the user has to decide what type to use
        to hold the bin counts and it is not an obvious choice. The integer needs
        to be large enough to avoid counter overflow, but if it is too large and
        only a fraction of the bits are used, then it is a waste of memory. Using
        floating point numbers is even more dangerous. They don't overflow, but cap
        the bin count when the bits in the mantissa are used up.
      </p>
<p>
        The standard storage used in the library is <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">boost::histogram::adaptive_storage</a></code>,
        which solves these issues in an effective way, based on the following insight.
      </p>
<p>
        The <a href="https://en.wikipedia.org/wiki/Curse_of_dimensionality" target="_top">curse
        of dimensionality</a> becomes a problem when the number of histogram
        axes grows, since the number of bins grows exponentially. High-dimensional
        histograms can consume GBs of memory. However, having many bins typically
        reduces the number of counts per bin, since the input values are spread over
        many more bins now. This suggests an adaptive solution: start with a minimum
        amount of memory per bin by using the smallest integer type to hold a count.
        If the bin counter is about to overflow, switch to the next larger integer
        type.
      </p>
<p>
        We start with 1 byte per bin counter and then double the size as needed,
        until 8 byte per bin are reached. When even that is not enough, we switch
        to the <a href="../../../../../libs/multiprecision/index.html" target="_top">Boost.Multiprecision</a>
        type <code class="computeroutput"><span class="identifier">cpp_int</span></code>, whose capacity
        is limited only by available memory. This approach is not only memory conserving,
        but also ultimately safe, because bin counters cannot overflow.
      </p>
<p>
        And now comes the best part: it is even often faster despite several overheads.
        We require dense storage and so need to resize all bin counters to the new
        size whenever any one counter is about to overflow. A new memory block is
        allocated with a uniformly larger cell size, then the content of the old
        memory is copied, and finally the old memory block is deallocated. This is
        a slow operation, but happens only O(logN) times for N bin increments. There
        is an runtime overhead involved in addressing bin counters of varying size.
        Nevertheless, the benchmarks show that this approach is faster for larger
        histograms than using fixed but large cell size, because the more compact
        size leads to better utilization of the CPU cache.
      </p>
<p>
        In a sense, <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">adaptive_storage</a></code>
        is the opposite of a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span></code>,
        which keeps the size of the stored type constant, but grows to hold a larger
        number of elements. Here, the number of elements remains the same, but the
        storage grows to hold a uniform collection of larger and larger elements.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.uoflow"></a><a class="link" href="rationale.html#histogram.rationale.uoflow" title="Overflow and underflow bins">Overflow and underflow bins</a>
</h3></div></div></div>
<p>
        The library supports extra bins that count values which fall below or above
        the range covered by the axis. These extra bins are called under- and overflow
        bins, respectively. The extra bins can be turned off individually for each
        axis at runtime to conserve memory, but are turned on by default. The extra
        bins do not interfere with normal bin counting. On an axis with <code class="computeroutput"><span class="identifier">n</span></code> bins, the first bin has the index <code class="computeroutput"><span class="number">0</span></code>, the last bin <code class="computeroutput"><span class="identifier">n</span><span class="special">-</span><span class="number">1</span></code>, while the
        under- and overflow bins are accessible at the indices <code class="computeroutput"><span class="special">-</span><span class="number">1</span></code> and <code class="computeroutput"><span class="identifier">n</span></code>,
        respectively.
      </p>
<p>
        Under- and overflow bins are useful in one-dimensional histograms, and nearly
        essential in multi-dimensional histograms. Here are the advantages:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            No loss: The total sum over all bin counts is strictly equal to the number
            of times <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...)</span></code>
            was called. Even NaN values are counted, they end up in the underflow
            bin by convention.
          </li>
<li class="listitem">
            Diagnosis: Unexpected extreme values show up in the extra bins, which
            otherwise might have been overlooked.
          </li>
<li class="listitem">
            Projectability: In multi-dimensional histograms, an out-of-range value
            along one axis may be paired with an in-range value along another axis.
            If under- and overflow bins are missing, such a value pair is lost. This
            distorts the histogram even along the axis where the value was in range.
            When under- and overflow bins are present, it is possible to project
            (projecting means summing up along all other axes) the histogram onto
            any axis and get the same result as if one had filled a histogram with
            only that axis.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.weights"></a><a class="link" href="rationale.html#histogram.rationale.weights" title="Variance estimates">Variance estimates</a>
</h3></div></div></div>
<p>
        Once a histogram is filled, the count <span class="emphasis"><em>k</em></span> in a bin can
        be queried with the <code class="computeroutput"><span class="identifier">value</span><span class="special">(...)</span></code> method. The histogram also offers a
        <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code>
        method, which returns an estimate of the <a href="https://en.wikipedia.org/wiki/Variance" target="_top">variance</a>
        <span class="emphasis"><em>v</em></span> of that count.
      </p>
<p>
        If the input values for the histogram come from a <a href="https://en.wikipedia.org/wiki/Stochastic_process" target="_top">stochastic
        process</a>, the variance provides useful additional information. Examples
        for a stochastic process are a physics experiment or a random person filling
        out a questionaire<a href="#ftn.histogram.rationale.weights.f0" class="footnote" name="histogram.rationale.weights.f0"><sup class="footnote">[1]</sup></a>. The variance <span class="emphasis"><em>v</em></span> is the square of the standard
        deviation. The standard deviation in a bin tells us how much we can expect
        the observed value to fluctuate around the <a href="https://en.wikipedia.org/wiki/Expected_value" target="_top">expected</a>
        number of counts <span class="emphasis"><em>lambda = p N</em></span>, where <span class="emphasis"><em>p</em></span>
        the probability for a random input value to fall into the range covered by
        the bin, and <span class="emphasis"><em>N</em></span> is the total number of input values sampled.
        Some examples how these two are used:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Error bars: Drawing a line (so-called <a href="https://en.wikipedia.org/wiki/Error_bar" target="_top">error
            bar</a>) over the interval <span class="emphasis"><em>(k - sqrt(v), k + sqrt(v))</em></span>
            is a simple visualisation of the expected random scatter of the bin value
            <span class="emphasis"><em>k</em></span>, if the histogram was cleared and filled again
            with another independent sample of the same size (e.g. by repeating the
            physics experiment or asking more people to fill a questionaire). If
            you compare the result with a fitted model (see next item), about 2/3
            of the error bars should overlap with the model.
          </li>
<li class="listitem">
            Least-squares fitting: Often you have a model of the expected number
            of counts <span class="emphasis"><em>lambda</em></span> per bin, which is a function of
            parameters with unknown values. A simple method to find good (sometimes
            the best) estimates for those parameter values is to vary them until
            the sum of squared residuals <span class="emphasis"><em>(k - lambda)^2/v</em></span> is
            minimized. This is the <a href="https://en.wikipedia.org/wiki/Least_squares" target="_top">method
            of least squares</a>, in which both the bin values <span class="emphasis"><em>k</em></span>
            and variance estimates <span class="emphasis"><em>v</em></span> enter.
          </li>
<li class="listitem">
            Pull distributions: If you have two histograms filled with the same number
            of samples and you want to know whether they are in agreement, you can
            compare the so-called pull distribution. It is formed by subtracting
            the counts and dividing by the square root of their variances <span class="emphasis"><em>(k1
            - k2)/sqrt(v1 + v2)</em></span>. If the histograms are identical, the
            pull distribution randomly scatters around zero, and about 2/3 of the
            values are in the interval <span class="emphasis"><em>[ -1, 1 ]</em></span>.
          </li>
</ul></div>
<p>
        Why return the variance <span class="emphasis"><em>v</em></span> and not the standard deviation
        <span class="emphasis"><em>s = sqrt(v)</em></span>? There are two reasons:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            Additivity: <a href="https://en.wikipedia.org/wiki/Variance#Properties" target="_top">Variances
            of independent samples can be added</a> like normal numbers <span class="emphasis"><em>v3
            = v1 + v2</em></span>. This is not true for standard deviations, where
            the addition law is more complex <span class="emphasis"><em>s3 = sqrt(s1^2 + s2^2)</em></span>.
            In that sense, the variance is the more fundamental quantity.
          </li>
<li class="listitem">
            Efficiency: Computing the variance requires fewer instructions. Therefore
            we return the variance and let the user optionally take the square-root
            to obtain the standard deviation as needed.
          </li>
</ul></div>
<p>
        How is the variance estimate <span class="emphasis"><em>v</em></span> computed? If we know
        the expected number of counts <span class="emphasis"><em>lambda</em></span> per bin, we could
        compute the variance as <span class="emphasis"><em>v = lambda</em></span>, because counts in
        a histogram follow the <a href="https://en.wikipedia.org/wiki/Poisson_distribution" target="_top">Poisson
        distribution</a> <a href="#ftn.histogram.rationale.weights.f1" class="footnote" name="histogram.rationale.weights.f1"><sup class="footnote">[2]</sup></a>. After filling a histogram, we do not know the expected number
        of counts <span class="emphasis"><em>lambda</em></span> for any particular bin, but we know
        the observed count <span class="emphasis"><em>k</em></span>, which is not too far from <span class="emphasis"><em>lambda</em></span>.
        We therefore might be tempted to just replace <span class="emphasis"><em>lambda</em></span>
        with <span class="emphasis"><em>k</em></span> in the formula <span class="emphasis"><em>v = lambda = k</em></span>.
        This is in fact the so-called non-parameteric estimate for the variance based
        on the <a href="https://en.wikipedia.org/wiki/Plug-in_principle" target="_top">plug-in
        principle</a>. It is the best (and only) estimate for the variance, if
        we know nothing more about the underlying stochastic process which generated
        the inputs (or want to feign ignorance about it).
      </p>
<p>
        Now, if the value returned by the method <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code> is just the same as the value return
        by <code class="computeroutput"><span class="identifier">value</span><span class="special">(...)</span></code>,
        why bother with adding a <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code> method, except perhaps for convenience?
        There is another reason, which becomes apparent if the histograms are filled
        with weighted counts, which is discussed next.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.weigths"></a><a class="link" href="rationale.html#histogram.rationale.weigths" title="Support of weights">Support of weights</a>
</h3></div></div></div>
<p>
        A histogram categorizes input values and increments a bin counter if an input
        value falls into the value range covered by that bin. The <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">standard
        storage</a></code> uses integer types to store these counts, see the <a class="link" href="rationale.html#histogram.rationale.storage_types" title="Storage types">storage section</a> how integer
        overflow is avoided. However, sometimes histograms need to be filled with
        values that have a weight <span class="emphasis"><em>w</em></span> attached to them. In this
        case, the corresponding bin counter is not increased by one, but by the passed
        weight <span class="emphasis"><em>w</em></span>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          There are many use cases for weighted fills. Here is an example from particle
          physics. Let us say the value to be histogrammed is the recorded energy
          of some particle that hit a detector. Let us further say that the detector
          sometimes misses the particle, if its energy is small (because it does
          not generate enough signal to be notice above the noise level). If the
          efficiency of the detector is known as a function of the energy, one can
          correct for the expected loss by weighting each energy with the inverse
          of the efficiency to on average compensate the loss.
        </p></td></tr>
</table></div>
<p>
        When the <code class="computeroutput"><a class="link" href="../boost/histogram/adaptive_storage.html" title="Class template adaptive_storage">adaptive_storage</a></code>
        is used, histograms may also be filled with weighted values. The choice of
        using weighted fills can be made at run-time. If the function <code class="computeroutput"><span class="identifier">wfill</span><span class="special">(...)</span></code>
        is used, two doubles per bin are stored (previous integer counts are automatically
        converted). The first double keeps track of the sum of weights. The second
        double keeps track of the sum of weights squared. The latter is the variance
        estimate in this case and returned by a call to <code class="computeroutput"><span class="identifier">variance</span><span class="special">(...)</span></code>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
          This variance estimate can be derived from the <a href="https://en.wikipedia.org/wiki/Variance#Properties" target="_top">mathematical
          properties of the variance</a>. Let us say a bin is filled <span class="emphasis"><em>k1</em></span>
          times with weight <span class="emphasis"><em>w1</em></span>. The sum of weights is then
          <span class="emphasis"><em>w1 k1</em></span>. It then follows from the variance properties
          that <span class="emphasis"><em>Var(w1 k1) = w1^2 Var(k1)</em></span>. Using the reasoning
          from before, the estimated variance of <span class="emphasis"><em>k1</em></span> is <span class="emphasis"><em>k1</em></span>,
          so that <span class="emphasis"><em>Var(w1 k1) = w1^2 Var(k1) = w1^2 k1</em></span>. Variances
          of independent samples are additive. If the bin is further filled <span class="emphasis"><em>k2</em></span>
          times with weight <span class="emphasis"><em>w2</em></span>, the sum of weights is <span class="emphasis"><em>w1
          k1 + w2 k2</em></span>, with variance <span class="emphasis"><em>w1^2 k1 + w2^2 k2</em></span>.
          This also holds for <span class="emphasis"><em>k1 = k2 = 1</em></span>. Therefore, the sum
          of weights <span class="emphasis"><em>w[i]</em></span> has variance sum of <span class="emphasis"><em>w[i]^2</em></span>.
          In other words, to incrementally keep track of the variance of the sum
          of weights, we need to keep track of the sum of weights squared.
        </p></td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.python_support"></a><a class="link" href="rationale.html#histogram.rationale.python_support" title="Python support">Python support</a>
</h3></div></div></div>
<p>
        Python is a popular scripting language in the data science community. Thus,
        the library provides Python bindings. The histogram may be used as an interface
        between a complex simulation or data-storage system written in C++ and data-analysis/plotting
        in Python. Users are able to define the histogram in Python, let it be filled
        on the C++ side, and then get it back for further data analysis or plotting.
      </p>
<p>
        Data analysis in Python is Numpy-based, so Numpy support is included. If
        number of dimensions is larger than one, this implementation is faster than
        the equivalent Numpy functions (while being more flexible), see <a class="link" href="benchmarks.html" title="Benchmarks">benchmark</a>.
      </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../../../../../doc/src/images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top">
<p>
          The Python and C++ interface use consistent naming, but sometimes Python
          offers more elegant and pythonic ways of implementing things. Where possible,
          the more pythonic interface is used.
        </p>
<p>
          Properties: Getter/setter-like functions are wrapped as properties. Examples:
          <code class="computeroutput"><span class="identifier">histogram</span><span class="special">.</span><span class="identifier">dim</span></code>, <code class="computeroutput"><span class="identifier">regular_axis</span><span class="special">.</span><span class="identifier">bins</span></code>.
        </p>
<p>
          Axis access: The <code class="computeroutput"><span class="identifier">histogram</span></code>
          object implements the sequence protocol and behaves like an immutable sequence
          of axes. Examples: <code class="computeroutput"><span class="identifier">len</span><span class="special">(</span><span class="identifier">histogram</span><span class="special">)</span></code> returns the number of axes, <code class="computeroutput"><span class="identifier">histogram</span><span class="special">[</span><span class="number">0</span><span class="special">]</span></code> accesses
          the first axis, <code class="computeroutput"><span class="keyword">for</span> <span class="identifier">axis</span>
          <span class="identifier">in</span> <span class="identifier">histogram</span><span class="special">:</span> <span class="special">[...]</span></code>
          iterates.
        </p>
<p>
          Keyword-based parameters: C++ member functions <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...)</span></code> and <code class="computeroutput"><span class="identifier">wfill</span><span class="special">(...)</span></code> are wrapped by the single Python member
          function <code class="computeroutput"><span class="identifier">fill</span><span class="special">(...)</span></code>
          with an optional keyword parameter <code class="computeroutput"><span class="identifier">w</span></code>
          to pass a weight.
        </p>
</td></tr>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="histogram.rationale.serialization"></a><a class="link" href="rationale.html#histogram.rationale.serialization" title="Serialization">Serialization</a>
</h3></div></div></div>
<p>
        Serialization is implemented using <a href="../../../../../libs/serialization/index.html" target="_top">Boost.Serialization</a>.
        Pickling in Python is implemented based on the C++ serialization code. In
        the current implementation, the pickled stream is <span class="bold"><strong>not</strong></span>
        portable, since it uses <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">archive</span><span class="special">::</span><span class="identifier">binary_archive</span></code>.
        It would be great to switch to a portable binary representation in the future,
        when that becomes available.
      </p>
</div>
<div class="footnotes">
<br><hr style="width:100; text-align:left;margin-left: 0">
<div id="ftn.histogram.rationale.weights.f0" class="footnote"><p><a href="#histogram.rationale.weights.f0" class="para"><sup class="para">[1] </sup></a>
          The choices of the person are most likely not random, but if we pick a
          random person from a group, we randomly sample from a pool of opinions
        </p></div>
<div id="ftn.histogram.rationale.weights.f1" class="footnote"><p><a href="#histogram.rationale.weights.f1" class="para"><sup class="para">[2] </sup></a>
          The Poisson distribution is correct as far as the counts <span class="emphasis"><em>k</em></span>
          themselves are of interest. If the fractions per bin <span class="emphasis"><em>p = k /
          N</em></span> are of interest, where <span class="emphasis"><em>N</em></span> is the total
          number of counts, then the correct distribution to describe the fractions
          is the <a href="https://en.wikipedia.org/wiki/Multinomial_distribution" target="_top">multinomial
          distribution</a>.
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2016, 2017 Hans Dembinski<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="benchmarks.html"><img src="../../../../../doc/src/images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../../../../../doc/src/images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../../../../../doc/src/images/home.png" alt="Home"></a><a accesskey="n" href="concepts.html"><img src="../../../../../doc/src/images/next.png" alt="Next"></a>
</div>
</body>
</html>
