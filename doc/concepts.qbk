[section Concepts]

Users can extend the library with new axis and storage types.

[section:axis_type Axis type]

An `axis_type` converts input values into bin indices.

An `axis_type` is required to:

* derive from [classref boost::histogram::axis::axis_base]
* be default/copy/move constructable
* be copy/move assignable
* be equal comparable
* have a nested type `value_type`, which is the type of the input values (may be a const reference if the input value is expensive to copy)
* have the following methods:
  * `int index(value_type x) const`: takes an input value and returns the bin index
  * `value_type operator[](int index) const`: takes a bin index and returns the low edge of the bin

For full support of all library features, the `axis_type` should also be:

* streamable, by implementing a free function `std::ostream operator<<(std::ostream&, const axis_type&)`
* serializable, by implementing a free function `template <class Archive> inline void serialize(Archive& ar, axis_type & axis, unsigned /* version */)`

The latter two are not needed, if the histogram that uses the custom axis type is never serialized or ostreamed.

It is recommended to take a look at the existing axis types, like [classref boost::histogram::axis::regular], which serve as templates to create new ones.

[endsect]

[section:storage_type Storage type]

A `storage_type` handles memory for the bin counters and provides a uniform interface for incrementing bin counters and reading their values.

A `storage_type` is required to:

* be default/copy/move constructable
* be copy/move assignable
* be equal comparable
* have a nested type `value_type`, the external type used to represent the bin count (internally it may be a different type)
* have a constructor `storage_type(std::size_t n)`, which prepares the storage of `n` bins.
* have the following methods:
  * `std::size_t size() const`
  * `void increase(std::size_t index)`
  * `void increase(std::size_t index, value_type n)`
  * `void add(std::size_t index, const value_type& val, const value_type& var)`
  * `value_type value(std::size_t index) const`
  * `value_type variance(std::size_t index) const`

To support weighted fills, an additional method is required:

* `void weighted_increase(std::size_t index, value_type weight)`

[classref boost::histogram::array_storage] is a simple storage type which does not support weighted fills. It may serve as a template to create a new storage type.

[endsect]

[endsect]
