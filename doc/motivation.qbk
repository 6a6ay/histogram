[section:motivation Motivation]

C++ lacks a widely-used, free histogram class. While it is easy to write a one-dimensional histogram, writing a general multi-dimensional histogram poses more of a challenge. If you add serialization and Python/Numpy support onto the wish-list, then the implementation becomes non-trivial and a well-tested library solution desirable.

The [@https://www.gnu.org/software/gsl GNU Scientific Library (GSL)] and in the [@https://root.cern.ch ROOT framework] from CERN have histogram implementations. The C implementations of the GSL are object oriented and elegant, but only support one and two dimensions. The implementations are not customizable, you have to live with the trade-offs chosen by the implementors. ROOT has implementations for one, two, three, and general n-dimensional histograms. However, the interfaces are unnecessarily complex and inconsistent, and mix many different responsibilities. They are also not well designed to prevent user errors. For example, the design forces users to make an educated decision on which data type to use that holds the counts, an aspect that the library should encapsulate. The ROOT implementations are also slow and inefficient due to heavy use of virtual inheritance. They are also not customizable.

The two histogram classes in this project share an interface which is as elegant as the GSL implementations. In addition, they are customizable through exchangable policies and user-supplied binning algorithms. Thanks to variadic templates, the interface is consistent for any number of dimensions. The implementations are also very fast, since they use of compile-time information wherever possible and [@boost:/libs/variant/index.html Boost.Variant] rather than virtual inheritance to achieve faster run-time polymorphism.

A central design goal was to completely encapsulate the counting details, so that the user does not have to think about it. The internal counting mechanism is independent of the external histogram interface and encapsulated in an exchangable storage policy. The standard policy implements a sophisticated counting approach which is very fast, memory-efficient, and safe, since counts can neither overflow nor lose precision. In the standard configuration, the histogram *just works* under any circumstance. Users with special requirements can still implement their own custom storage policy or use the alternative container-based storage policy. With the latter, for example, and in conjunction with a [@boost:/libs/array/index.html Boost.Array], it is possible to construct a histogram entirely on the stack.

[endsect]