[section:benchmarks Benchmarks]

The library is designed to be fast. While it is unlikely that the time spend in the histogram is limiting an application, we cannot predict how the library is used.

The following plot shows results of a benchmark on a 2.9 GHz Macbook Pro. Random numbers from a uniform and a normal distribution are filled into histograms with 1, 3, and 6 axes. 100 bins are used in the first case, 100x100x100=10^6 in the second, and 10x10x10x10x10x10=10^6 in the third. Each test is repeated 50 times and the minimum time is taken.

There are two bars per benchmarked histogram. The upper is for random data from a uniform distribution which never falls outside the axis range. The lower is for random data from a normal distribution, which falls outside of the axis range in about 10 % of the cases. The second differs slightly because of branch-prediction misses.

[$../benchmark.png [width 5in] [height 5in]]

[variablelist Plot legend:
	[[root] [[@https://root.cern.ch ROOT classes] (`TH1I` for 1D, `TH3I` for 3D and `THnI` for 6D)]]
	[[py:numpy] [numpy functions ([python]`numpy.histogram` for 1D, `numpy.histogramdd` for 2D, 3D, and 6D)]]
	[[gsl] [[@https://www.gnu.org/software/gsl/doc/html/histogram.html GSL histograms] for 1D and 2D]]
    [[hs_ss] [Histogram with `std::tuple<axis::regular<>>` and [classref std::vector<int>]]]
	[[hs_sd] [Histogram with `std::tuple<axis::regular<>>` with [classref boost::histogram::default_storage]]]
	[[hd_ss] [Histogram with `std::vector<axis::variant<axis::regular<>>>` with [classref std::vector<int>]]]
	[[hd_sd] [Histogram with `std::vector<axis::variant<axis::regular<>>>` with [classref boost::histogram::default_storage]]]
]

A histogram with compile-time configured axes is always faster than one with run-time configured axes. [classref boost::histogram::default_storage] is faster than a `std::vector<int>` for histograms with many bins, because it uses the cache more effectively due to its smaller memory consumption per bin. If the number of bins is small, it is slower because of the overhead of handling memory dynamically.

The histograms in this library are mostly faster than the competition, sometimes by a factor of 2. Simultaneously they are more much more flexible, since binning strategies and the counter management can be customised.

[endsect]
